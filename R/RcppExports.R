# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute pairwise frequencies
#'
#' It returns a 5-rows matrix with each combination of items and categories as columns.
#' Row0: item k, Row1: item l, Row2; category item k, Row3: category item l, Row4: freq
#' It is computed just once, before the optimization of the complete pairwise
#'
#' @param Y Integer matrix of dimension \eqn{n*p}, where \eqn{n} is the sample size
#' and \eqn{p} is the number of items considered. Categories must be coded starting from zero.
#' For example, an item with three categories can only accept values contained in
#' \eqn{\{0, 1, 2\}}.
#' @param C_VEC Integer vector indicating how many possible categories are associated to
#' each item in 'Y'.
#' @export
pairs_freq <- function(Y, C_VEC) {
    .Call(`_plFA_pairs_freq`, Y, C_VEC)
}

#' Get loading matrix from theta
#'
#' get_Lam() constructs the loading matrix from the parameter vector
#'
#' @param THETA Numerical vector of parameters.
#' @param A Binary matrix of dimension \eqn{p*q} where \eqn{p} is the number
#' of items and \eqn{q} the number of latent variables. Entries equal to
#' \eqn{1} refer to free loadings, while entries equal to \eqn{0} indicate
#' loadings constrained to be null.
#' @param C Sum of the number of categories for each item.
get_Lam <- function(A, C, THETA) {
    .Call(`_plFA_get_Lam`, A, C, THETA)
}

#' Get transformed parameters from latent correlation matrix
#'
#' Use Lewandowski-Kurowicka-Joe (2009) transformation on latent correlations
#' with Choleski decomposition.
#'
#' @param S Latent correlation matrix.
#' @export
get_par_from_S <- function(S) {
    .Call(`_plFA_get_par_from_S`, S)
}

#' Get latent correlation matrix from theta
#'
#' get_S() extracts the latent correlation matrix from theta assuming
#' theta elements to be reparametrised following the
#' Lewandowski-Kurowicka-Joe (2009) transform.
#'
#' @param THETA Numerical vector of parameters.
#' @param Q Number of latent variables.
#'
#' @export
get_S <- function(THETA, Q) {
    .Call(`_plFA_get_S`, THETA, Q)
}

grad_S <- function(A, THETA, IDX) {
    .Call(`_plFA_grad_S`, A, THETA, IDX)
}

#' Full pairwise iteration
#'
#' @description
#' Evaluate negative loglikelihood or gradient of the complete pool of pairs.
#' Used by external optimisers. Multithreading options via `RcppParallel`.
#'
#' @param N Number of observations
#' @param C_VEC Vector containing the number of categories for each item
#' @param CONSTRMAT Constraint matrix. Loadings free to be estimated are identified by a 1.
#' @param THETA Parameter vector
#' @param FREQ Frequency table
#' @param CORRFLAG 1 to estimate latent correlations. 0 for orthogonal latent factors.
#' @param GRFLAG 0 to only compute the likelihood. 1 to also compute the gradient.
#' @param SILENTFLAG optional for verbose output
#'
multiThread_completePairwise <- function(N, C_VEC, CONSTRMAT, THETA, FREQ, CORRFLAG, GRFLAG = 1L, SILENTFLAG = 1L) {
    .Call(`_plFA_multiThread_completePairwise`, N, C_VEC, CONSTRMAT, THETA, FREQ, CORRFLAG, GRFLAG, SILENTFLAG)
}

#' Full pairwise likelihood
#'
#' @description
#' Evaluate negative loglikelihood. Same structure of `multiThread_completePairwise`.
#' Used to monitor validation log-likelihood. Multithreading options via `RcppParallel`.
#'
#' @param N Number of observations
#' @param C_VEC Vector containing the number of categories for each item
#' @param CONSTRMAT Constraint matrix. Loadings free to be estimated are identified by a 1.
#' @param THETA Parameter vector
#' @param FREQ Frequency table
#' @param CORRFLAG 1 to estimate latent correlations. 0 for orthogonal latent factors.
#' @param SILENTFLAG optional for verbose output
#'
multiThread_completePairwise_nll <- function(N, C_VEC, CONSTRMAT, THETA, FREQ, CORRFLAG, SILENTFLAG) {
    .Call(`_plFA_multiThread_completePairwise_nll`, N, C_VEC, CONSTRMAT, THETA, FREQ, CORRFLAG, SILENTFLAG)
}

#' Stochastic optimiser
#'
#' @description
#' Core function to evaluate stochastic estimators
#'
#' @param FREQ Frequency table.
#' @param VALFREQ Frequency table validation data.
#' @param N Number of observations.
#' @param C_VEC Vector containing the number of categories for each item.
#' @param CONSTRMAT Constraint matrix. Loadings free to be estimated are identified by a 1.
#' @param THETA_INIT Initial parameter vector
#' @param CORRFLAG 1 to estimate latent correlations. 0 for orthogonal latent factors.
#' @param METHODFLAG 0 for hypergeometric, 1 for Bernoulli.
#' @param PAIRS_PER_ITERATION Number of pairs to draw per iteration.
#' @param ETA Initial stepsize.
#' @param BURN Initial burn-in period.
#' @param MAXT Maximum number of iterations.
#' @param TOLCOUNT Tolerance count for convergence with validation nll.
#' @param SILENTFLAG Silent output.
#' @param TOL Tolerance level.
#' @param EACHCLOCK How often (in terms of iterations) to measure single iteration computational times (using \code{RcppClock}..
#' @param PAR1 Hyperparameter for stepsize scheduling by Xu (2011): Scaling.
#' @param PAR2 Hyperparameter for stepsize scheduling by Xu (2011): Smallest Hessian eigenvalue.
#' @param PAR3 Hyperparameter for stepsize scheduling by Xu (2011): Decay rate.
#' @param STEPSIZEFLAG Choose stepsize scheduling: Set 0 for Polyak and Juditsky (1992), 1 for Xu (2011).
#' @param CHECKCONV Flag to check for convergence using complete pairwise likelihood on the validation set.
#' @param EACHCHECK  How often (in terms of iterations) to check for convergence.
#' @param SEED Randomising seed.
#'
plFA <- function(FREQ, VALFREQ, N, C_VEC, CONSTRMAT, THETA_INIT, CORRFLAG, METHODFLAG, PAIRS_PER_ITERATION, ETA, BURN, MAXT, TOLCOUNT = 50L, SILENTFLAG = 1L, TOL = 1e-6, EACHCLOCK = 100L, PAR1 = 1, PAR2 = 1, PAR3 = .75, STEPSIZEFLAG = 0L, CHECKCONV = 0L, EACHCHECK = 100L, SEED = 123L) {
    .Call(`_plFA_plFA`, FREQ, VALFREQ, N, C_VEC, CONSTRMAT, THETA_INIT, CORRFLAG, METHODFLAG, PAIRS_PER_ITERATION, ETA, BURN, MAXT, TOLCOUNT, SILENTFLAG, TOL, EACHCLOCK, PAR1, PAR2, PAR3, STEPSIZEFLAG, CHECKCONV, EACHCHECK, SEED)
}

sampling_step <- function(FULL_POOL, METHODFLAG, PROB, PAIRS_PER_ITERATION, N_ITEMS, SEED, SILENTFLAG, ITER) {
    .Call(`_plFA_sampling_step`, FULL_POOL, METHODFLAG, PROB, PAIRS_PER_ITERATION, N_ITEMS, SEED, SILENTFLAG, ITER)
}

#' Single pair contribution
#'
#' @description
#' Wrapper of pair_contribution() used for unit tests
#'
#' @param A Constraint matrix. Loadings free to be estimated are identified by a 1.
#' @param C_VEC Vector containing the number of categories for each item
#' @param THETA Parameter vector
#' @param CORRFLAG 1 to estimate latent correlations. 0 for orthogonal latent factors.
#' @param k first index identifying the pair
#' @param l second index identifying the pair
#' @param PAIRS_TABLE output from [pairs_freq()]
#' @param SILENTFLAG optional for verbose output
#' @param GRADFLAG 1 to compute gradient
compute_pair <- function(A, C_VEC, THETA, CORRFLAG, k, l, PAIRS_TABLE, SILENTFLAG, GRADFLAG) {
    .Call(`_plFA_compute_pair`, A, C_VEC, THETA, CORRFLAG, k, l, PAIRS_TABLE, SILENTFLAG, GRADFLAG)
}

#' Estimate of H
#'
#' @description
#' Compute a sample estimate of the expected negative Hessian by taking
#' advantage of the second Bartlett's identity at the single pair level
#'
#' @param A Constraint matrix. Loadings free to be estimated are identified by a 1.
#' @param C_VEC Vector containing the number of categories for each item
#' @param THETA Parameter vector
#' @param CORRFLAG 1 to estimate latent correlations. 0 for orthogonal latent factors.
#' @param FREQ output from [pairs_freq()]
#' @param N sample size
estimate_H <- function(C_VEC, A, THETA, FREQ, N, CORRFLAG) {
    .Call(`_plFA_estimate_H`, C_VEC, A, THETA, FREQ, N, CORRFLAG)
}

#' Estimate of J
#'
#' @description
#' Compute a sample estimate of the variability matrix via the sample average outer product
#' of the composite score
#'
#' @param A Constraint matrix. Loadings free to be estimated are identified by a 1.
#' @param C_VEC Vector containing the number of categories for each item
#' @param THETA Parameter vector
#' @param CORRFLAG 1 to estimate latent correlations. 0 for orthogonal latent factors.
#' @param Y data matrix
estimate_J <- function(Y, C_VEC, A, THETA, CORRFLAG) {
    .Call(`_plFA_estimate_J`, Y, C_VEC, A, THETA, CORRFLAG)
}

